"use strict";(self.webpackChunkreact_learning=self.webpackChunkreact_learning||[]).push([[804],{804:(e,n,t)=>{t.r(n),t.d(n,{default:()=>c});t(43);var s=t(579);function c(){return(0,s.jsxs)("div",{style:{fontFamily:"Arial, sans-serif",lineHeight:"1.6",padding:"20px",maxWidth:"800px",margin:"auto"},children:[(0,s.jsx)("h1",{style:{color:"#4A90E2"},children:"React Effect Hook (useEffect)"}),(0,s.jsxs)("section",{style:{marginBottom:"20px"},children:[(0,s.jsx)("h2",{children:"What is useEffect?"}),(0,s.jsxs)("p",{children:[(0,s.jsx)("strong",{children:"useEffect"})," is a Hook that lets you perform side effects in functional components. Side effects include data fetching, subscriptions, manually changing the DOM, and more."]})]}),(0,s.jsxs)("section",{style:{marginBottom:"20px"},children:[(0,s.jsx)("h2",{children:"Basic Example"}),(0,s.jsxs)("p",{children:["Using ",(0,s.jsx)("code",{children:"useEffect"})," to update the document title whenever the count changes:"]}),(0,s.jsx)("pre",{style:{background:"#f5f5f5",padding:"10px",borderRadius:"5px"},children:"import React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]); // Runs only when 'count' changes\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}"})]}),(0,s.jsxs)("section",{style:{marginBottom:"20px"},children:[(0,s.jsx)("h2",{children:"Key Points"}),(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"useEffect"})," runs after the render is committed to the screen."]}),(0,s.jsx)("li",{children:"The second argument is an array of dependencies. The effect runs when any dependency changes."}),(0,s.jsxs)("li",{children:["If you pass an empty array ",(0,s.jsx)("code",{children:"[]"}),", the effect runs only once, similar to ",(0,s.jsx)("code",{children:"componentDidMount"}),"."]}),(0,s.jsx)("li",{children:"Return a cleanup function from the effect to handle unmounting or cleanup tasks."})]})]}),(0,s.jsxs)("section",{style:{marginTop:"20px"},children:[(0,s.jsx)("h2",{children:"Example with Cleanup"}),(0,s.jsx)("pre",{style:{background:"#f5f5f5",padding:"10px",borderRadius:"5px"},children:"function Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n\n    // Cleanup function\n    return () => clearInterval(interval);\n  }, []);\n\n  return <p>Seconds elapsed: {seconds}</p>;\n}"})]}),(0,s.jsxs)("section",{style:{marginTop:"20px"},children:[(0,s.jsx)("h2",{children:"Summary"}),(0,s.jsxs)("p",{children:[(0,s.jsx)("strong",{children:"useEffect"})," replaces lifecycle methods like ",(0,s.jsx)("code",{children:"componentDidMount"}),",",(0,s.jsx)("code",{children:"componentDidUpdate"}),", and ",(0,s.jsx)("code",{children:"componentWillUnmount"})," in functional components. It is the key tool for handling side effects in React."]})]})]})}}}]);
//# sourceMappingURL=804.c772275d.chunk.js.map